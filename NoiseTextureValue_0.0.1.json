{
  "author": "",
  "category": "Advanced",
  "extensionNamespace": "",
  "fullName": "Noise texture value",
  "helpPath": "https://github.com/GuestGD",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDojRkZGRkZGO30NCjwvc3R5bGU+DQo8cGF0aCBkPSJNMjUsMEg3QzUuMywwLDQsMS4zLDQsM3YyNmMwLDEuNywxLjMsMywzLDNoMThjMS43LDAsMy0xLjMsMy0zVjNDMjgsMS4zLDI2LjcsMCwyNSwweiBNMTAsMjhjLTEuMSwwLTItMC45LTItMnMwLjktMiwyLTINCglzMiwwLjksMiwyUzExLjEsMjgsMTAsMjh6IE0xMCwyMmMtMS4xLDAtMi0wLjktMi0yczAuOS0yLDItMnMyLDAuOSwyLDJTMTEuMSwyMiwxMCwyMnogTTEwLDE2Yy0xLjEsMC0yLTAuOS0yLTJzMC45LTIsMi0yDQoJczIsMC45LDIsMlMxMS4xLDE2LDEwLDE2eiBNMTYsMjhjLTEuMSwwLTItMC45LTItMnMwLjktMiwyLTJzMiwwLjksMiwyUzE3LjEsMjgsMTYsMjh6IE0xNiwyMmMtMS4xLDAtMi0wLjktMi0yczAuOS0yLDItMg0KCXMyLDAuOSwyLDJTMTcuMSwyMiwxNiwyMnogTTE2LDE2Yy0xLjEsMC0yLTAuOS0yLTJzMC45LTIsMi0yczIsMC45LDIsMlMxNy4xLDE2LDE2LDE2eiBNMjIsMjhjLTEuMSwwLTItMC45LTItMnMwLjktMiwyLTINCglzMiwwLjksMiwyUzIzLjEsMjgsMjIsMjh6IE0yMiwyMmMtMS4xLDAtMi0wLjktMi0yczAuOS0yLDItMnMyLDAuOSwyLDJTMjMuMSwyMiwyMiwyMnogTTIyLDE2Yy0xLjEsMC0yLTAuOS0yLTJzMC45LTIsMi0yDQoJczIsMC45LDIsMlMyMy4xLDE2LDIyLDE2eiBNMjQsOWMwLDAuNi0wLjQsMS0xLDFIOWMtMC42LDAtMS0wLjQtMS0xVjVjMC0wLjYsMC40LTEsMS0xaDE0YzAuNiwwLDEsMC40LDEsMVY5eiIvPg0KPC9zdmc+DQo=",
  "name": "NoiseTextureValue",
  "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/Glyphster Pack/Master/SVG/Education and Learning/b23cbcd219b9b4165b101bdae4654d32e939a946162376d469cb34cd4a2d5e32_Education and Learning_education_calculator_maths.svg",
  "shortDescription": "Read noise texture value",
  "version": "0.0.1",
  "description": "Read noise texture value",
  "tags": [
    "perlin noise texture value random math"
  ],
  "authorIds": [
    "W0yoMQqOeiULIwY1i1Qd8tprOyD2"
  ],
  "dependencies": [],
  "eventsFunctions": [
    {
      "description": "Read noise texture",
      "fullName": "Read noise texture",
      "functionType": "Action",
      "name": "ReadNoiseTexture",
      "sentence": "Read noise texture: _PARAM1_ Noise name: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "const deltaTime = runtimeScene.getTimeManager().getElapsedTime() / 1000.0;",
            "const noiseName = eventsFunctionContext.getArgument(\"noiseName\");",
            "",
            "function samplePerlinNoise(texture, x, y, noiseName) {",
            "    if (!texture || !texture.image) {",
            "        return 0; ",
            "    };",
            "",
            "    // Ensure canvas dimensions match texture dimensions",
            "    const canvasKey = `perlinNoiseCanvas_${noiseName}`;",
            "    const contextKey = `perlinNoiseContext_${noiseName}`;",
            "",
            "    if (!threeScene.userData[canvasKey] || threeScene.userData[canvasKey].width !== texture.image.width || threeScene.userData[canvasKey].height !== texture.image.height) {",
            "        threeScene.userData[canvasKey] = document.createElement('canvas');",
            "        threeScene.userData[canvasKey].width = texture.image.width;",
            "        threeScene.userData[canvasKey].height = texture.image.height;",
            "        threeScene.userData[contextKey] = threeScene.userData[canvasKey].getContext('2d');",
            "    };",
            "",
            "    const canvas = threeScene.userData[canvasKey];",
            "    const context = threeScene.userData[contextKey];",
            "",
            "    context.clearRect(0, 0, canvas.width, canvas.height);",
            "    context.drawImage(texture.image, 0, 0);",
            "",
            "    const intX = x; ",
            "    const intY = y; ",
            "",
            "    if (intX < 0 || intX >= canvas.width || intY < 0 || intY >= canvas.height) {",
            "        console.error(\"Coordinates out of bounds:\", intX, intY);",
            "        return 0;",
            "    }",
            "",
            "    const pixelData = context.getImageData(intX, intY, 1, 1).data;",
            "    return pixelData[0] / 255.0; // Normalize to [0, 1] range",
            "}",
            "",
            "let perlinNoiseTexture;",
            "if (!threeScene.userData.noiseTextures) {",
            "    threeScene.userData.noiseTextures = {};",
            "};",
            "",
            "if (!threeScene.userData.noiseTextures[noiseName]) {",
            "    const textureLoader = new THREE.TextureLoader();",
            "    const textureMapName = eventsFunctionContext.getArgument(\"source\");",
            "    const textureFileName = textureMapName.substring(textureMapName.lastIndexOf('\\\\') + 1);",
            "    ",
            "    perlinNoiseTexture = textureLoader.load(textureFileName, (texture) => {",
            "        if (!texture.image) {",
            "            console.error(\"Loaded texture has no image.\");",
            "        }; ",
            "",
            "        threeScene.userData.noiseTextures[noiseName].textureLoaded = true;",
            "    }, undefined, (error) => {",
            "    });",
            "    ",
            "    threeScene.userData.noiseTextures[noiseName] = {",
            "        texture: perlinNoiseTexture,",
            "        textureLoaded: false,",
            "        value: 0",
            "    };",
            "} else {",
            "    perlinNoiseTexture = threeScene.userData.noiseTextures[noiseName].texture;",
            "}",
            "",
            "// Ensure the texture is fully loaded before proceeding",
            "if (!threeScene.userData.noiseTextures[noiseName].textureLoaded) {",
            "    return;",
            "};",
            "",
            "if (!threeScene.userData.phase) {",
            "    threeScene.userData.phase = 'right';",
            "    threeScene.userData.currentX = 1;",
            "    threeScene.userData.currentY = 1;",
            "}",
            "",
            "const { phase, currentX, currentY } = threeScene.userData;",
            "",
            "// Function to update coordinates based on the current phase",
            "function updateCoordinates() {",
            "    switch (phase) {",
            "        case 'right':",
            "            if (currentX < perlinNoiseTexture.image.width-1) {",
            "                threeScene.userData.currentX++;",
            "            } else {",
            "                threeScene.userData.phase = 'down';",
            "                threeScene.userData.currentY++;",
            "            }",
            "            break;",
            "        case 'down':",
            "            if (currentY < perlinNoiseTexture.image.height-1) {",
            "                threeScene.userData.currentY++;",
            "            } else {",
            "                threeScene.userData.phase = 'left';",
            "                threeScene.userData.currentX--;",
            "            }",
            "            break;",
            "        case 'left':",
            "            if (currentX > 1) {",
            "                threeScene.userData.currentX--;",
            "            } else {",
            "                threeScene.userData.phase = 'up';",
            "                threeScene.userData.currentY--;",
            "            }",
            "            break;",
            "        case 'up':",
            "            if (currentY > 1) {",
            "                threeScene.userData.currentY--;",
            "            } else {",
            "                threeScene.userData.phase = 'right';",
            "                threeScene.userData.currentX++;",
            "            }",
            "            break;",
            "    }",
            "};",
            "",
            "let noiseValue;",
            "",
            "if (threeScene.userData.noiseTextures[noiseName].textureLoaded) {",
            "    // Sample the texture at the current coordinates",
            "    noiseValue = samplePerlinNoise(perlinNoiseTexture, currentX, currentY, noiseName);",
            "    threeScene.userData.noiseTextures[noiseName].value = noiseValue;",
            "",
            "    // Update coordinates for the next iteration",
            "    updateCoordinates();",
            "} else {",
            "    noiseValue = 1;",
            "    threeScene.userData.noiseTextures[noiseName].value = noiseValue;",
            "};"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Noise texture",
          "name": "source",
          "type": "imageResource"
        },
        {
          "description": "Noise custom name",
          "name": "noiseName",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Noise value",
      "fullName": "Noise value",
      "functionType": "ExpressionAndCondition",
      "name": "NoiseValueExpression",
      "sentence": "Noise value name: _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "const noiseName = eventsFunctionContext.getArgument(\"noiseName\");",
            "",
            "if (threeScene) {",
            "    if (threeScene.userData && threeScene.userData.noiseTextures && threeScene.userData.noiseTextures[noiseName]) {",
            "        eventsFunctionContext.returnValue = threeScene.userData.noiseTextures[noiseName].value;",
            "    };",
            "};"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Noise name",
          "name": "noiseName",
          "type": "string"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}